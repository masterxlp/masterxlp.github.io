I"?H<ul id="markdown-toc">
  <li><a href="#寻找两个正序数组的中位数" id="markdown-toc-寻找两个正序数组的中位数">寻找两个正序数组的中位数</a>    <ul>
      <li><a href="#题目描述" id="markdown-toc-题目描述">题目描述</a></li>
      <li><a href="#示例" id="markdown-toc-示例">示例</a></li>
      <li><a href="#我的解题思路及代码" id="markdown-toc-我的解题思路及代码">我的解题思路及代码</a></li>
      <li><a href="#其他方法" id="markdown-toc-其他方法">其他方法</a></li>
    </ul>
  </li>
  <li><a href="#最长回文字串" id="markdown-toc-最长回文字串">最长回文字串</a>    <ul>
      <li><a href="#题目描述-1" id="markdown-toc-题目描述-1">题目描述</a></li>
      <li><a href="#示例-1" id="markdown-toc-示例-1">示例</a></li>
      <li><a href="#题解" id="markdown-toc-题解">题解</a>        <ul>
          <li><a href="#暴力匹配" id="markdown-toc-暴力匹配">暴力匹配</a></li>
          <li><a href="#动态规划" id="markdown-toc-动态规划">动态规划</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>题目来自：<a href="https://leetcode.com/">LeetCode</a>、<a href="https://leetcode-cn.com/">LeetCode-cn</a><br />
该部分主要包含本人对LeetCode题目的自答以及题解社区中的优质回答的综述，包括代码和解题思路</p>
</blockquote>

<h2 id="寻找两个正序数组的中位数">寻找两个正序数组的中位数</h2>
<h3 id="题目描述">题目描述</h3>
<p>给定两个大小为 m 和 n 的正序数组 nums1 和 nums2。
请找出这两个正序数组的中位数，并且要求算法的时间复杂度为 $O(log(m+n))$。
假设 nums1 和 nums2 不会同时为空。</p>

<h3 id="示例">示例</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 示例1

nums1 = [1,3]
nums2 = [2]

则中位数是 2.0

// 示例2

nums1 = [1,2]
nums2 = [3,4]

则中位数是 (2 + 3) / 2 = 2.5
</code></pre></div></div>

<h3 id="我的解题思路及代码">我的解题思路及代码</h3>
<p>首先，能最快想到的就是暴力法，即对数组中的所有值进行重新排序，然后取中位数，但是该方法的时间复杂度最差时为 $O(m+n)$，不满足题目中的时间复杂度的要求。
但是，只是为了寻找中位数，因此，不必进行完全排序，只需进行 $\frac{m+n}{2}$ 次的排序即可。</p>

<p>又注意到，假设 nums1 和 nums2 不会同时为空，因此，必然存在一种情况那就是，nums1 和 nums2 其中一个为空的情况，且 num1 和 num2 本身是有序的。
因此，第一种情况是：num1 和 num2 有一个为空，这时寻找中位数其实就是不为空的那个数组的中间值，时间复杂度为 $O(1)$。
第二种情况是：num1 和 num2 均不为空，这时我们最差只需要寻找 $\frac{m+n}{2}$ 次即可找到。
具体见代码。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def findMedianSortedArrays(nums1, nums2):
    nums1_len = len(nums1)
    nums2_len = len(nums2)
    
    length = nums1_len + nums2_len
    
    if length % 2 != 0:
        index = int(length // 2)
    else:
        index = (int(length / 2) - 1, int(length / 2))
    
    # Case 1. nums1 和 nums2 有一个为空
    if nums1_len == 0 or nums2_len == 0:
        nums = nums1 if nums2_len == 0 else nums2
        if type(index) is int:
            return float(nums[index])
        else:
            return float((nums[index[0]] + nums[index[1]]) / 2)
    # Case 2. nums1 和 nums2 均为空
    elif nums1_len == 0 and nums2_len == 0:
        raise ValueError("Both arrays are empty.")
    # Case 3. nums1 和 nums2 均不为空
    else:
        num = index if type(index) is int else index[-1]
        a, b = 0, 0
        for i in range(num):
            num1 = nums1[a]
            num2 = nums2[b]
            # 分情况讨论：num1 &lt; num2 和 num1 &gt; num2，这两种情况时对称的，解决一个另外一个也就解决了
            if num1 &lt; num2:
                a += 1
                # 讨论：当某一个数组的索引超过其最大限度但还未停止寻找
                if a &gt;= nums1_len and i &lt; num - 1:
                    if type(index) is int:
                        r = nums2[b + num - i - 1]
                        break
                    else:
                        r = float((nums2[b + num - i - 1] + nums2[b + num - i - 2]) / 2)
                        break
                # 讨论：当某一个数组的索引超过其最大限度但已到达停止寻找的条件
                elif a &gt;= nums1_len and i == num - 1:
                    if type(index) is int:
                        r = float(max(num1, num2))
                        break
                    else:
                        r = float((num1 + num2) / 2)
                        break
                # 讨论：当某一个数组的索引未超过其最大限度但已到达停止寻找的条件
                elif i == num - 1 and a &lt; nums1_len:
                    f_num1 = nums1[a]
                    num2 = num2 if f_num1 &gt; num2 else f_num1
            else:
                b += 1
                if b &gt;= nums2_len and i &lt; num - 1:
                    if type(index) is int:
                        r = nums1[a + num - i - 1]
                        break
                    else:
                        r = float((nums1[a + num - i - 1] + nums1[a + num - i - 2]) / 2)
                        break
                elif b &gt;= nums2_len and i == num - 1:
                    if type(index) is int:
                        r = float(max(num1, num2))
                        break
                    else:
                        r = float((num1 + num2) / 2)
                        break
                elif i == num - 1 and b &lt; nums2_len:
                    f_num2 = nums2[b]
                    num1 = num1 if f_num2 &gt; num1 else f_num2
            if i == num - 1:
                if type(index) is int:
                    r = float(max(num1, num2))
                else:
                    r = float((num1 + num2) / 2)
        return r
</code></pre></div></div>

<h3 id="其他方法">其他方法</h3>
<p>二分查找：目标是找到一条分割线，该分割线两边的元素满足一下两个条件：</p>
<ul>
  <li>满足分割线两边元素个数的关系：当 $m + n$ 为奇数时，分割线左边的元素个数比分割线右边的元素个数多一个；当 $m + n$ 为偶数时，分割线两边的元素的个数相等；</li>
  <li>满足交叉小于等于关系：第一个数组分割线左边的第一个元素的数值要小于第二个数组分割线右边的第一个元素的数值；第二个数组分割线左边的第一个元素的数值也要小于第一个数组分割线右边的第一个元素的数值；</li>
</ul>

<p>第一个条件是由中位数的特性决定的：中位数实际上就是在有序数组最中间的那个数，中位数两边的数值是相等的（不包含中位数本身）。
第二个条件是由有序数组决定的，该方法成立的条件也是：两个数组必须为有序数组。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def findMedianSortedArrays(nums1, nums2):
    if len(nums1) &gt; len(nums2):
        return findMedianSortedArrays(nums2, nums1)

    # 定义一个极大、极小数，以应对分割线的左边或右边没有数可比较的情况
    infinty = 2**40
    m, n = len(nums1), len(nums2)

    # 计算分割线左边总共需要有多少个元素：奇数时左边为 (m + n + 1) // 2 偶数时左边为 (m + n) // 2
    # 但是为了不区分奇偶情况，利用整除为向下取正的特性，定义统一表达式 (m + n + 1) // 2
    totalLeft = (m + n + 1) // 2

    left, right = 0, m
    median1, median2 = 0, 0

    # 二分查找逻辑：
    # 1. 定义：分割线在第一个数组右边的第一个元素的下标 i = 分割线在第一个数组左边的元素的个数
    #         分割线在第二个数组右边的第一个元素的下标 j = 分割线在第二个数组左边的元素的个数
    #    其中，i, j 满足：(m + n + 1) / 2 = i + j
    # 2. 分割线需满足的条件为：nums1[i-1] &lt;= nums2[j] &amp;&amp; nums2[j-1] &lt;= nums1[i]

    while left &lt;= right:
        i = (left + right) // 2
        j = totalLeft - i

        nums_im1 = -infinty if i == 0 else nums1[i-1]       # 第一个数组分割线左边的最大值
        nums_i = infinty if i == m else nums1[i]            # 第一个数组分割线右边的最小值
        nums_jm1 = -infinty if j == 0 else nums2[j-1]       # 第二个数组分割线左边的最大值
        nums_j = infinty if j == n else nums2[j]            # 第二个数组分割线右边的最小值

        if nums_im1 &lt;= nums_j:
            median1, median2 = max(nums_im1, nums_jm1), min(nums_i, nums_j)        # 第一个中位数为分割线左边的最大值，第二个中位数为分割线右边的最小值
            left = i + 1
        else:
            right = i - 1

    return (median1 + median2) / 2 if (m + n) % 2 == 0 else float(median1)
</code></pre></div></div>

<ul>
  <li>其时间复杂度为 $O(log min(m, n))$</li>
  <li>空间复杂度为 $O(1)$</li>
</ul>

<h2 id="最长回文字串">最长回文字串</h2>
<h3 id="题目描述-1">题目描述</h3>
<p>给定一个字符串s，找到s中最长的回文子串。可以假设s的最大长度不超过1000。</p>

<h3 id="示例-1">示例</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入："babad"
输出："bab"
注意："aba" 也是一个答案

输入："cbbd"
输出："bb"
</code></pre></div></div>

<h3 id="题解">题解</h3>
<h4 id="暴力匹配">暴力匹配</h4>
<p>暴力匹配法的思路：遍历所有长度大于等于2的子串，依次判断它们是否是回文字串，再从其中找到最长的回文字串返回。</p>

<p>在实现时，我们可以只记录回文字串的起始位置以及回文串的长度即可，这样我们就可以找到所有的回文子串。</p>

<p>由于题目中要求我们寻找最长的回文字串，那么我们可以通过维护一个maxLen变量的形式来记录最长回文子串的长度以及一个begin变量来记录最长回文子串的其实位置即可。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def longestPalindrome(s):
    stringLen = len(s)
    if stringLen &lt; 2:
        return s

    # 定义两个变量来分别表示最长回文子串的起始位置和长度
    begin, maxLen = 0, 1

    # 遍历所有长度大于等于2的子串，并判断它们是否为回文
    for i in range(stringLen - 1):                                    # 左边界的范围：[0, 字符串长度 - 2]
        for j in range(i + 1, stringLen):                             # 右边界的范围：[1, 字符串长度 - 1]
            if j - i + 1 &gt; maxLen and validPalindromic(s, i, j):      # 如果为回文串，那么它的长度：右边界值 - 左边界值 + 1
                maxLen = j - i + 1
                begin = i
    return s[begin: begin + maxLen]

def validPalindromic(string, left, right):
    while left &lt; right:
        if string[left] != string[right]:
            return False
        left += 1
        right -= 1

    return True
</code></pre></div></div>

<ul>
  <li>时间复杂度
    <ul>
      <li>外层循环维护左边界，内层循环维护右边界，最内层循环验证子串是否为回文字串</li>
      <li>外层总共循环 $n-1$ 次，每一次外循环时，内层总共循环 $n-1, n-2, \cdots, 1$，每一次内循环时，内部还有一层循环，最差的情况就是循环 $n-1, n-2, \cdots, 1$</li>
      <li>因此，时间复杂度为 $(n-1)^2 + (n-2)^2 + \cdots + 1^2 = \frac{(n (n-1) (2n-1))}{6}$，$O(\frac{(n (n-1) (2n-1))}{6}) = O(n^3)$</li>
    </ul>
  </li>
  <li>空间复杂度
    <ul>
      <li>因为。仅使用了常数个临时变量，与字符串的长度无关</li>
      <li>因此，空间复杂度为 $O(1)$</li>
    </ul>
  </li>
</ul>

<h4 id="动态规划">动态规划</h4>

<blockquote>
  <p>“动态规划”的“规划”（programming）就是“填表格”的意思，所以“动态规划”也叫“表格法”，它就是“以空间换时间”思想的体现。
而“动态”（dynamic）的意思是“从一个最基本的问题出发”。 <br />
它不像我们熟悉的“递归+记忆化”的方法。 <br />
“递归+记忆化”的方法是直接对问题求解，遇到新的问题，就先记录一下，再遇到的时候直接读取，这种方式叫“自顶向下”。
“动态”的思路是“自底向上”，我们通过发现这个问题“最初的样子”，即 <strong>从一个最基本的问题出发，逐步计算中间过程，最后得到要求问题的解</strong>。
“动态”的思想就体现在，我们不是直接面对要解决的问题。</p>
</blockquote>

<p>回文串的特点是：字符串无论是正读还是反读都是相同的。
那么，对于一个回文串来说：在去头尾的两个字符后，它依然满足回文串的特性。
因此，从最内层开始，依次向外扩张，如果每一个子串都是回文串的话，那么该字符串就是回文串。
这种思想就是动态规划。</p>

<p>于是，<br />
动态规划关于本题的解题思路，有：<br />
「动态规划」的一个关键步骤就是要想清楚「状态如何转移」。
而事实上，「回文」就天然地具有「状态转移」的性质，即「一个回文去掉首尾后，剩余部分仍然是回文」。</p>

<p>因此，从 <strong>回文的定义</strong> 来看，有：</p>
<ul>
  <li>如果一个字符串的头尾两个字符都不相同，那么该字符串一定不是回文串</li>
  <li>反之，如果一个字符串的头尾相同，那么它有可能是回文串，这时需要进一步向内判断：
    <ul>
      <li>如果内部的子串是回文串，那么该字符串为回文串</li>
      <li>反之，如果内部的子串不构成回文串时，这整个字符串都不构成回文串</li>
    </ul>
  </li>
</ul>

<p>即，有：<strong>在头尾字符相同的情况下，内部子串的回文性决定了整个子串的回文性</strong>，这就是状态转移。
因此，可以把「状态」定义为原字符串的一个子串是否为回文串。</p>

<p>过程讨论：<br />
<strong>第一步：定义状态</strong></p>

<p><code class="highlighter-rouge">dp[i][j]</code>表示子串<code class="highlighter-rouge">s[i:j]</code>是否为回文子串，注意，这里子串<code class="highlighter-rouge">s[i:j]</code>定义为左闭右闭区间，即可以取到<code class="highlighter-rouge">s[i]</code>和<code class="highlighter-rouge">s[j]</code>。</p>

<p><strong>第二步：状态转移方程</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
</code></pre></div></div>
<p>说明：</p>
<ul>
  <li>「动态规划」事实上是在填一张二维表格，表格的行与列均为该字符串，由于需要构成子串，因此<code class="highlighter-rouge">i</code>与<code class="highlighter-rouge">j</code>的关系是<code class="highlighter-rouge">i &lt;= j</code>，又因对称性的存在，因此，只需填写对角线以上的部分即可</li>
  <li>由于 <code class="highlighter-rouge">dp[i+1][j-1]</code>，因此需要考虑边界情况，以防越界</li>
  <li>边界条件为：<code class="highlighter-rouge">[i+1, j-1]</code>不构成区间，即长度严格小于<code class="highlighter-rouge">2</code>，于是有，<code class="highlighter-rouge">j - 1 - (i + 1) + 1 &lt; 2</code>，即 <code class="highlighter-rouge">j - i &lt; 3</code></li>
  <li>显然，<code class="highlighter-rouge">j - i &lt; 3</code>等价于<code class="highlighter-rouge">j - i + 1 &lt; 4</code>，即当子串 <code class="highlighter-rouge">s[i:j]</code> 的长度等于<code class="highlighter-rouge">2</code>或<code class="highlighter-rouge">3</code>时，其实只需判断一下首尾两个字符是否相等即可</li>
</ul>

<p>因此，在 <code class="highlighter-rouge">s[i] == s[j]</code> 和 <code class="highlighter-rouge">j - i &lt; 3</code> 成立的前提下，可以直接说 <code class="highlighter-rouge">dp[i][j] = True</code>，否则才执行状态转移。</p>

<p><strong>第三步：初始化</strong></p>

<p>初始化整个表格为False，由于单个字符必然构成回文串，因此，初始化对角线上的元素为True。</p>

<p><strong>第四步：输出</strong></p>

<p>为了节省空间，提升性能，我们仅在 <code class="highlighter-rouge">dp[i][j] = True</code> 时，记录最长回文子串的「起始位置」和「回文长度」即可，而不需要保存整个字符串。</p>

<p><strong>第五步：优化</strong></p>

<p>这里不进行优化。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def longestPalindrome(s):
    if len(s) &lt; 2:
        return s
    
    dp = [[False for _ in range(len(s))] for _ in range(len(s))]       # 初始化表格
    
    begin, maxLen = 0, 1
    
    for i in range(len(s)):                                            # 初始化对角线
        dp[i][i] = True
    
    for j in range(1, len(s)):                                         # 从上到下，从左到右的填表
        for i in range(0, j):
            if s[i] == s[j]:                                           # 边界判断
                if j - i &lt; 3:
                    dp[i][j] = True                                    # 两则都满足时，必然为回文子串
                else:
                    dp[i][j] = dp[i+1][j-1]                            # 状态转移
            else:
                dp[i][j] = False
            
            if dp[i][j]:
                curLen = j - i + 1  
                if curLen &gt; maxLen:                                    # 记录最长子串的起始位置和回文长度
                    maxLen = curLen
                    begin = i
    
    return s[begin: begin+maxLen]
</code></pre></div></div>

:ET